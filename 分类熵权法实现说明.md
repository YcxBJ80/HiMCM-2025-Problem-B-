# 分类熵权法实现说明

## 一、方法概述

### 1.1 传统熵权法的局限性

传统的熵权法将所有指标放在一起计算权重，这种方法存在以下问题：

1. **指标异质性**：不同类别的指标（如能源消费、价格、碳排放）具有不同的量纲和含义，直接合并可能导致某些类别被忽略
2. **信息损失**：不同类别内部的指标相关性可能较高，但类别之间的相关性较低，直接合并可能无法充分利用类别内部的信息
3. **权重分配不均**：某些类别可能包含更多指标，导致该类别的总体影响过大

### 1.2 分类熵权法的优势

分类熵权法采用"先分类，后合并"的两阶段方法：

1. **第一阶段：分类内熵权计算**
   - 将指标按照业务逻辑分为5个类别：能源消费类、能源价格类、碳排放类、经济人口类、气候环境类
   - 在每个类别内部，使用熵权法计算各指标的权重
   - 在每个类别内部，计算各州的分类分数

2. **第二阶段：分类间合并**
   - 将各分类的分数作为新的"指标"
   - 再次使用熵权法计算各分类的权重
   - 加权合并各分类分数，得到最终的综合分数

这种方法的好处：
- **更科学的权重分配**：既考虑了类别内部的指标重要性，又考虑了类别之间的重要性
- **更好的可解释性**：可以清楚地看到每个类别对最终分数的贡献
- **更合理的评估**：避免了不同类别指标直接混合带来的问题

## 二、代码结构

### 2.1 模块组织

```
src/
├── category_mapping.py          # 指标分类映射模块
├── run_categorized_entropy_model.py  # 分类熵权法主程序
├── entropy_model.py             # 熵权法核心算法
└── data_cleaning.py             # 数据清洗模块
```

### 2.2 核心模块说明

#### 2.2.1 `category_mapping.py` - 指标分类映射

**功能**：根据指标名称将指标分配到对应的分类。

**关键函数**：

1. **`classify_indicator(indicator_name: str) -> Optional[str]`**
   - 输入：指标名称
   - 输出：分类名称（如果无法匹配则返回None）
   - 逻辑：
     - 将指标名称转换为小写
     - 按优先级顺序检查每个分类的关键词
     - 如果包含排除关键词，则跳过该分类
     - 如果包含该分类的关键词，则返回该分类

2. **`classify_indicators(indicator_names: Dict[str, str]) -> Dict[str, str]`**
   - 批量分类指标
   - 输入：字典，key为indicator_id，value为indicator_name
   - 输出：字典，key为indicator_id，value为分类名称

3. **`get_category_indicators(classification: Dict[str, str], category: str) -> List[str]`**
   - 获取指定分类下的所有指标ID

**分类定义**：

代码中定义了5个分类及其关键词：

- **能源消费类**：包含各种能源的消费和生产指标，如天然气消费、可再生能源消费、核能发电等
- **能源价格类**：包含能源价格和支出指标，如平均价格、总支出等
- **碳排放类**：包含CO2排放相关指标，如总排放量、人均排放、碳强度等
- **经济人口类**：包含GDP和人口指标
- **气候环境类**：包含气候相关指标，如加热度日、冷却度日等

#### 2.2.2 `run_categorized_entropy_model.py` - 分类熵权法主程序

**主要流程**：

1. **数据加载与预处理**
   ```python
   long_frame, metadata = load_all_indicators(args.data_dir)
   features = build_feature_matrix(long_frame, args.year, ...)
   ```
   - 加载所有Excel文件中的指标数据
   - 构建特征矩阵（州 × 指标）

2. **指标分类**
   ```python
   classification = classify_indicators(indicator_names)
   ```
   - 根据指标名称将指标分配到对应分类
   - 统计每个分类的指标数量

3. **分类内熵权计算**
   ```python
   for category in CATEGORY_KEYWORDS.keys():
       scores, model, weights = compute_category_scores(...)
   ```
   - 对每个分类：
     - 筛选该分类下的指标
     - 构建该分类的特征矩阵
     - 使用熵权法计算指标权重
     - 计算各州的分类分数

4. **分类间合并**
   ```python
   composite_scores, merge_weights = merge_category_scores(category_scores_dict)
   ```
   - 将各分类分数合并为DataFrame
   - 再次使用熵权法计算各分类的权重
   - 加权合并得到最终综合分数

5. **结果输出**
   - 保存各分类的分数和权重
   - 保存分类合并权重
   - 生成可视化图表

**关键函数**：

1. **`compute_category_scores(...)`**
   - 计算单个分类的熵权分数
   - 输入：特征矩阵、分类名称、该分类的指标列表等
   - 输出：分类分数、分类模型、分类权重

2. **`merge_category_scores(category_scores_dict)`**
   - 合并各分类的分数
   - 使用熵权法计算各分类的权重
   - 返回合并后的综合分数和分类权重

3. **`plot_category_weights(...)`**
   - 绘制各分类权重的条形图

4. **`plot_category_comparison(...)`**
   - 绘制各分类分数对比图，展示不同类别对最终分数的贡献

#### 2.2.3 `entropy_model.py` - 熵权法核心算法

这是熵权法的核心实现，包含以下关键步骤：

1. **数据标准化**（`_normalize`）
   - 根据指标方向（benefit/cost）进行标准化
   - benefit类型：值越大越好
   - cost类型：值越小越好

2. **概率计算**（`_probability`）
   - 将标准化后的数据转换为概率分布

3. **熵值计算**（`_entropy`）
   - 使用信息熵公式计算各指标的信息熵
   - 公式：$E_j = -k \sum_{i=1}^{m} p_{ij} \ln(p_{ij})$
   - 其中 $k = 1/\ln(m)$，$m$ 为样本数

4. **权重计算**
   - 计算信息熵的差异度：$d_j = 1 - E_j$
   - 归一化得到权重：$w_j = d_j / \sum_{j=1}^{n} d_j$

5. **分数计算**
   - 加权求和：$S_i = \sum_{j=1}^{n} w_j \cdot x_{ij}$
   - 归一化到0-100：$S_i' = S_i / \max(S) \times 100$

## 三、使用方法

### 3.1 运行分类熵权法模型

```bash
python src/run_categorized_entropy_model.py \
    --data-dir . \
    --output-dir outputs \
    --year 2023 \
    --min-feature-coverage 0.85 \
    --min-state-coverage 0.8
```

### 3.2 参数说明

- `--data-dir`：包含原始Excel文件的目录（默认：当前目录）
- `--output-dir`：输出目录（默认：`outputs`）
- `--year`：构建特征矩阵的年份（默认：2023）
- `--min-feature-coverage`：保留特征所需的最小州数据覆盖率（默认：0.85）
- `--min-state-coverage`：对州进行评分所需的最小特征覆盖率（默认：0.8）

### 3.3 输出文件

运行后会生成以下文件：

**中间数据**：
- `outputs/intermediate/indicator_classification_2023.csv`：指标分类映射表

**模型结果**：
- `outputs/model/state_scores_能源消费类_2023.csv`：能源消费类分数
- `outputs/model/state_scores_能源价格类_2023.csv`：能源价格类分数
- `outputs/model/state_scores_碳排放类_2023.csv`：碳排放类分数
- `outputs/model/state_scores_经济人口类_2023.csv`：经济人口类分数
- `outputs/model/state_scores_气候环境类_2023.csv`：气候环境类分数
- `outputs/model/state_scores_categorized_2023.csv`：**最终综合分数**
- `outputs/model/category_indicator_weights_2023.csv`：各分类内指标权重
- `outputs/model/category_merge_weights_2023.csv`：**分类合并权重**
- `outputs/model/category_models_2023.json`：各分类模型详情
- `outputs/model/categorized_summary_2023.json`：模型摘要

**可视化图表**：
- `outputs/figures/category_weights_2023.png`：各分类权重图
- `outputs/figures/category_comparison_2023.png`：各分类分数对比图

## 四、算法原理详解

### 4.1 熵权法数学原理

熵权法是一种客观赋权方法，基于信息熵理论。信息熵越大，说明指标的信息量越小，权重越低；反之，信息熵越小，说明指标的信息量越大，权重越高。

**步骤1：数据标准化**

对于benefit类型指标（越大越好）：
$$x_{ij}' = \frac{x_{ij} - \min_j}{\max_j - \min_j}$$

对于cost类型指标（越小越好）：
$$x_{ij}' = \frac{\max_j - x_{ij}}{\max_j - \min_j}$$

**步骤2：计算概率分布**

$$p_{ij} = \frac{x_{ij}' + \epsilon}{\sum_{i=1}^{m}(x_{ij}' + \epsilon)}$$

其中 $\epsilon$ 是一个很小的正数，避免 $\ln(0)$。

**步骤3：计算信息熵**

$$E_j = -k \sum_{i=1}^{m} p_{ij} \ln(p_{ij})$$

其中 $k = 1/\ln(m)$，$m$ 为样本数（州的数量）。

**步骤4：计算权重**

差异度：$$d_j = 1 - E_j$$

权重：$$w_j = \frac{d_j}{\sum_{j=1}^{n} d_j}$$

### 4.2 分类熵权法的两阶段过程

**第一阶段：分类内熵权计算**

对每个分类 $C_k$（$k = 1, 2, ..., 5$）：

1. 筛选该分类下的指标：$I_k = \{i_1, i_2, ..., i_{n_k}\}$
2. 构建分类特征矩阵：$X_k \in \mathbb{R}^{m \times n_k}$（$m$ 个州，$n_k$ 个指标）
3. 使用熵权法计算指标权重：$w_k = \{w_{k1}, w_{k2}, ..., w_{kn_k}\}$
4. 计算分类分数：$S_k = X_k \cdot w_k^T$

**第二阶段：分类间合并**

1. 构建分类分数矩阵：$S = [S_1, S_2, ..., S_5] \in \mathbb{R}^{m \times 5}$
2. 使用熵权法计算分类权重：$W = \{W_1, W_2, ..., W_5\}$
3. 计算最终综合分数：$S_{final} = S \cdot W^T$

### 4.3 为什么分类熵权法更科学？

1. **考虑了指标的结构性**：不同类别的指标具有不同的业务含义，分类处理可以更好地反映这种结构性

2. **避免了量纲问题**：虽然标准化可以解决量纲问题，但不同类别的指标在标准化后仍然可能具有不同的分布特征，分类处理可以更好地处理这种差异

3. **提高了可解释性**：可以清楚地看到每个类别对最终分数的贡献，便于理解和解释结果

4. **更合理的权重分配**：既考虑了类别内部的指标重要性，又考虑了类别之间的重要性，避免了某些类别被忽略的问题

## 五、代码示例

### 5.1 分类映射示例

```python
from category_mapping import classify_indicator

# 分类指标
indicator1 = "Natural gas total consumption (including supplemental gaseous fuels)"
category1 = classify_indicator(indicator1)
print(category1)  # 输出: 能源消费类

indicator2 = "Natural gas average price"
category2 = classify_indicator(indicator2)
print(category2)  # 输出: 能源价格类

indicator3 = "Total energy CO2 emissions"
category3 = classify_indicator(indicator3)
print(category3)  # 输出: 碳排放类
```

### 5.2 计算分类分数示例

```python
from run_categorized_entropy_model import compute_category_scores

# 假设已有特征矩阵和元数据
category_indicators = ["indicator1", "indicator2", ...]
orientation_map = {"indicator1": "cost", "indicator2": "benefit", ...}

scores, model, weights = compute_category_scores(
    features=features,
    category="能源消费类",
    category_indicators=category_indicators,
    orientation_map=orientation_map,
    metadata=metadata
)

print(f"分类分数:\n{scores}")
print(f"指标权重:\n{weights}")
```

### 5.3 合并分类分数示例

```python
from run_categorized_entropy_model import merge_category_scores

category_scores_dict = {
    "能源消费类": scores1,
    "能源价格类": scores2,
    "碳排放类": scores3,
    "经济人口类": scores4,
    "气候环境类": scores5,
}

composite_scores, merge_weights = merge_category_scores(category_scores_dict)

print(f"综合分数:\n{composite_scores}")
print(f"分类权重:\n{merge_weights}")
```

## 六、结果解读

### 6.1 分类权重解读

`category_merge_weights_2023.csv` 文件中的权重表示各分类对最终综合分数的重要性：

- 权重越大，说明该分类的信息量越大，对最终分数的影响越大
- 权重越小，说明该分类的信息量越小，对最终分数的影响越小

### 6.2 综合分数解读

`state_scores_categorized_2023.csv` 文件中的分数是最终的综合分数：

- 分数范围：0-100
- 分数越高，说明该州的综合表现越好
- 分数是各分类分数的加权平均，权重由熵权法自动确定

### 6.3 分类分数对比

通过 `category_comparison_2023.png` 图表可以：

- 查看各州在不同分类中的表现
- 识别各州的优势和劣势类别
- 理解综合分数的构成

## 七、扩展与改进

### 7.1 可能的改进方向

1. **动态分类权重**：可以根据不同年份的数据特点，动态调整分类权重
2. **多层级分类**：可以进一步细分分类，形成多层级结构
3. **交互式可视化**：可以创建交互式图表，方便探索不同分类的贡献
4. **敏感性分析**：可以分析分类权重对最终结果的影响

### 7.2 自定义分类

如果需要修改分类标准，可以编辑 `category_mapping.py` 中的 `CATEGORY_KEYWORDS` 字典：

```python
CATEGORY_KEYWORDS = {
    "新分类名称": {
        "keywords": ["关键词1", "关键词2", ...],
        "exclude_keywords": ["排除关键词1", ...],
    },
    ...
}
```

## 八、参考文献

1. Shannon, C. E. (1948). A mathematical theory of communication. Bell System Technical Journal, 27(3), 379-423.
2. 熵权法在综合评价中的应用研究
3. 多指标综合评价方法及其应用

---

**注意**：本文档详细解释了分类熵权法的实现原理和使用方法。如有问题，请参考代码注释或联系开发者。

